<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta charset="UTF-8">
  <style>
      body {
          margin: 0;
          overflow: hidden;
          background-color: #000000;
      }
      canvas {
          display: block;
      }
  </style>
</head>
<body>

  <canvas id="canvas" style="object-fit: contain; width: 100vw; height: 100vh;"></canvas>

  <script>
  const text = "₳";
  const chng = .7;//.7-.95
  const cubeSize = 21;
  let redStop = getRandomRange(0.15, 0.25);  // Red stops earlier
  let whiteStopStart = redStop + getRandomRange(0.05, 0.10); // White starts soon after red
  let whiteStopEnd = whiteStopStart + getRandomRange(0.15, 0.25); // White stays longer
  let blueStop = getRandomRange(whiteStopEnd + 0.05, 1.0); // Blue starts later

/*Release canvas from memory*/
function releaseCanvas(canvas) {
canvas.width = 1;
canvas.style.width = "1vw";
canvas.height = 1;
canvas.style.height = "1vh";
const ctx = canvas.getContext('2d');
ctx && ctx.clearRect(0, 0, 1, 1);
canvas.remove();
}

//initialize canvas
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
// Set canvas dimensions
canvas.width = 3840;
canvas.height = 2160;

//variables
let startTime = Date.now();
let fadeToColor = false;
let fading = false;
let explosionTriggered = false; // Prevents multiple explosions per cycle
let nextColor;
const fontSize = 3072;
const cubes = [];
let isAndroid = /Android/i.test(navigator.userAgent);
let isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
let colors = [];
let snake = [];
let currentColorIndex = 0; // Global index of the "base" color
const colorChangeSpeed = 100;


//Cube class
class Cube {
    constructor(x, y, targetX, targetY, maxHoverOffset) {
        this.x = x;
        this.y = y;
        this.targetX = targetX;
        this.targetY = targetY;
        this.colorIndex = currentColorIndex; // start with the current base color
        this.size = cubeSize;
        this.neighbors = [];
        this.visited = false; // marks if cube has been changed during the cycle
        this.hoverOffsetX = (Math.random() - 0.5) * maxHoverOffset;
        this.hoverOffsetY = (Math.random() - 0.5) * maxHoverOffset;
        this.maxHoverOffset = maxHoverOffset;
    }
    draw() {
        ctx.fillStyle = colors[this.colorIndex];
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.fillStyle = 'rgba(0,0,0,.7)';
        ctx.fillRect(this.x + this.size * 0.1, this.y + this.size * 0.1, this.size, this.size);
    }
    update() {
        const speed = 0.03;
        const hoverDistance = 5;
        if (Math.random() < 0.1) {
            this.hoverOffsetX = (Math.random() - 0.5) * this.maxHoverOffset;
            this.hoverOffsetY = (Math.random() - 0.5) * this.maxHoverOffset;
        }
        const targetX = this.targetX + this.hoverOffsetX;
        const targetY = this.targetY + this.hoverOffsetY;
        const deltaX = targetX - this.x;
        const deltaY = targetY - this.y;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        if (distance > hoverDistance) {
            this.x += (deltaX / distance) * speed * distance;
            this.y += (deltaY / distance) * speed * distance;
        }
    }
    changeColor() {
        // Cycle cube's color from its current value
        this.colorIndex = (this.colorIndex + 1) % colors.length;
    }
    fadeToSingleColor(targetColorIndex, alpha) {
        const currentRGB = colors[this.colorIndex].match(/\d+/g).map(Number);
        const targetRGB = colors[targetColorIndex].match(/\d+/g).map(Number);
        const newRGB = currentRGB.map((c, i) => Math.floor(c + (targetRGB[i] - c) * alpha));
        this.colorIndex = colors.findIndex(
            color => color === `rgb(${newRGB[0]}, ${newRGB[1]}, ${newRGB[2]})`
        );
        if (this.colorIndex === -1) {
            colors.push(`rgb(${newRGB[0]}, ${newRGB[1]}, ${newRGB[2]})`);
            this.colorIndex = colors.length - 1;
        }
    }
}

function getRandomColor(excludeColor) {
    let color;
    do {
        color = `rgb(${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)}, ${Math.floor(Math.random() * 256)})`;
    } while (color === excludeColor);
    return color;
}

// Fixed palette: red, white, blue
function assignRandomColors() {
    colors = [
        "rgb(255, 0, 0)",    // red
        "rgb(255, 255, 255)",// white
        "rgb(0, 0, 255)"     // blue
    ];
    // Set initial base color to red (index 0)
    currentColorIndex = 0;
}

function initCubes() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.font = `${fontSize}px Arial`;
    const textWidth = ctx.measureText(text).width;
    const textHeight = fontSize;
    const startX = (canvas.width - textWidth) / 2;
    const startY = (canvas.height + textHeight) / 2.375;
    const offsets = [
        { x: 0, y: 0 },
        { x: 30, y: 0 },
        { x: -30, y: 0 },
        { x: 0, y: 30 },
        { x: 0, y: -30 },
        { x: 15, y: 15 },
        { x: -15, y: -15 },
        { x: 15, y: -15 },
        { x: -15, y: 15 }
    ];


    // Draw the text in black then in the main color (currentColorIndex)
    ctx.fillStyle = 'black';
    ctx.fillText(text, startX, startY);
    offsets.forEach(offset => {
        ctx.fillStyle = colors[currentColorIndex];
        ctx.fillText(text, startX + offset.x, startY + offset.y);
    });
    const textData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
    for (let y = 0; y < canvas.height; y += cubeSize) {
        for (let x = 0; x < canvas.width; x += cubeSize) {
            const index = (y * canvas.width + x) * 4;
            if (textData[index + 3] > 128) {
                let maxHoverOffset = isAndroid ? 3000 : (isIOS ? 2000 : 3000);
                const cube = new Cube(x, y, x, y, maxHoverOffset);
                cubes.push(cube);
            }
        }
    }
    cubes.forEach(cube => {
        cube.neighbors = cubes.filter(other =>
            other !== cube &&
            Math.abs(other.targetX - cube.targetX) <= cubeSize &&
            Math.abs(other.targetY - cube.targetY) <= cubeSize
        );
    });
}

const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height); // Horizontal gradient
function getRandomRange(min, max) {
       return Math.random() * (max - min) + min;
   }


               gradient.addColorStop(0, "red");
               gradient.addColorStop(redStop, "red");
               gradient.addColorStop(whiteStopStart, "white");
               gradient.addColorStop(whiteStopEnd, "white");
               gradient.addColorStop(blueStop, "blue");
               gradient.addColorStop(1, "blue");

function animate() {
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    cubes.forEach(cube => {
        cube.update();
        cube.draw();
    });
    requestAnimationFrame(animate);
}

function waveColorChange() {
    const snakeSize = 50;
    if (!fading) {
        if (snake.length === 0) {
            const randomCube = cubes[Math.floor(Math.random() * cubes.length)];
            snake.push(randomCube);
            randomCube.visited = true;
        }
        for (let i = 0; i < snake.length; i++) {
            const cube = snake[i];
            cube.changeColor();
            const neighbors = cube.neighbors.filter(neighbor => !neighbor.visited);
            if (neighbors.length > 0) {
                const nextCube = neighbors[Math.floor(Math.random() * neighbors.length)];
                snake[i] = nextCube;
                nextCube.visited = true;
            } else {
                snake.splice(i, 1);
                i--;
            }
        }
        while (snake.length < snakeSize) {
            const lastCube = snake[snake.length - 1];
            let nextCube;
            const potentialNeighbors = lastCube.neighbors.filter(cube => !cube.visited);
            if (potentialNeighbors.length > 0) {
                nextCube = potentialNeighbors[Math.floor(Math.random() * potentialNeighbors.length)];
            } else {
                nextCube = lastCube.neighbors[Math.floor(Math.random() * lastCube.neighbors.length)];
            }
            if (nextCube) {
                snake.push(nextCube);
                nextCube.visited = true;
            } else {
                break;
            }
        }
        if (snake.length === 0) {
            const randomCube = cubes[Math.floor(Math.random() * cubes.length)];
            snake.push(randomCube);
            randomCube.visited = true;
        }
    }

    // Use currentColorIndex as the base.
    const changedCount = cubes.filter(cube => cube.colorIndex !== currentColorIndex).length;
    if ((Date.now() - startTime >= 15000 || (changedCount / cubes.length) >= chng) && !fading && !explosionTriggered) {
        explosionTriggered = true;
        // Do not clear the canvas here so explosion trails remain
        fadeToColor = true;
        fadeStartTime = Date.now();
        // Force next color to be the next in the cycle (red→white→blue→red...)
        nextColor = (currentColorIndex + 1) % colors.length;
        fading = true;
        snake = [];
        cubes.forEach(cube => {
            cube.visited = false;
            cube.colorIndex = nextColor;
        });
    }

    // Explosion (fading) phase
    if (fadeToColor) {
        const fadeDuration = 1000; // 2 seconds fade
        const elapsedTime = Date.now() - fadeStartTime;
        const alpha = Math.min(elapsedTime / fadeDuration, 1);
        cubes.forEach(cube => {
            cube.fadeToSingleColor(nextColor, alpha);
            if (isAndroid) {
                cube.maxHoverOffset = 2600 - (2570 * alpha);
            } else if (isIOS) {
                cube.maxHoverOffset = 1700 - (1670 * alpha);
            } else {
                cube.maxHoverOffset = 2600 - (2570 * alpha);
            }
        });
        if (elapsedTime >= fadeDuration) {
            fadeToColor = false;
            fading = false;
            explosionTriggered = false;
            startTime = Date.now();
            // Update the base color for the next cycle:
            currentColorIndex = nextColor;
        }
    }

    // After explosion, spread cubes out if 15 seconds have passed and not fading.
    if (!fading && Date.now() - startTime >= 15000) {
        const maxRadius = Math.min(canvas.width, canvas.height) / 2;
        const center = { x: canvas.width / 2, y: canvas.height / 2 };
        cubes.forEach(cube => {
            const deltaX = cube.x - center.x;
            const deltaY = cube.y - center.y;
            const angle = Math.atan2(deltaY, deltaX);
            cube.targetX = center.x + Math.cos(angle) * maxRadius;
            cube.targetY = center.y + Math.sin(angle) * maxRadius;
            cube.colorIndex = Math.floor(Math.random() * colors.length);
        });
    }
}

function updateCubes() {
    const fadeDuration = 1000;
    const elapsedTime = Date.now() - startTime;
    const alpha = Math.min(elapsedTime / fadeDuration, 1);
    cubes.forEach(cube => {
      if (isAndroid) {
          cube.maxHoverOffset = 2600 - (2570 * alpha);
      } else if (isIOS) {
          cube.maxHoverOffset = 1700 - (1670 * alpha);
      } else {
          cube.maxHoverOffset = 2600 - (2570 * alpha);
      }
    });
    if (elapsedTime < fadeDuration) {
        requestAnimationFrame(updateCubes);
    }
}

// Initial drawing
ctx.fillStyle = 'black';
ctx.fillRect(0, 0, canvas.width, canvas.height);

// Initialize and start animation
assignRandomColors();
initCubes();
updateCubes();
animate();
setInterval(waveColorChange, colorChangeSpeed);

// Reload on canvas click
let timer;
        canvas.addEventListener("click", e => e.detail === 1 && (timer = setTimeout(() => location.reload(), 275)));

        canvas.addEventListener("dblclick", () => {
          clearTimeout(timer);
    const link = document.createElement('a');
    link.download = 'USADA.png';
    link.href = canvas.toDataURL();
    link.click();
});


function initCanvas() {
    //attachCanvasEventListeners();
}

initCanvas();
setTimeout(() => {
    initCanvas();
}, 15000);



/*Run release even when they refresh not with click (F5, refresh button, closing page)*/
      window.addEventListener('pagehide', (event) => {
      /*Release every canvas*/
      var canvases = document.getElementsByTagName("canvas");
      var canvasesList = Array.prototype.slice.call(canvases);
            canvasesList.forEach(releaseCanvas);
      });

</script>
</body>
</html>
