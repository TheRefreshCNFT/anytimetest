<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000000;
    }
    #canvas {
      display: block;
      object-fit: contain;
      width: 100vw;
      height: 100vh;
    }
    .modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #555;
      padding: 20px;
      border-radius: 10px;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      box-shadow: 0 0 20px gold;
      z-index: 10;
    }
    .modal button {
      padding: 10px;
      background: #000;
      color: gold;
      border: none;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 0 10px gold;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
    const c1 = '#08B6CE';
    const c2 = '#74D5DD';
    const c3 = '#398AD7';
    const c4 = '#2F66A9';
    const xBrd = 100;
    const yBrd = 100;
    const dRsize = 60;
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const htmlColors = [c1, c2, c3,c4];
    let increment = Math.random() * (500 - 300) + 300;
    /*draw on canvas with border
    const centerX = getRandomDec(xBrd, canvas.width - xBrd);
    const centerY = getRandomDec(yBrd, canvas.height - yBrd);
    */

    function getRandomDec(min, max) {
      return Math.random() * (max - min) + min;
    }

    function randomColor() {
      return '#' + (Math.random() * 0xFFFFFF << 0).toString(16).padStart(6, '0');
    }

    // Set canvas size dynamically based on window size
    function setCanvasSize() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;

      // Reinitialize the drawing after resizing
      redrawCanvas();
    }

    // Redraw the canvas content after resizing
    function redrawCanvas() {
      const centerX = getRandomDec(xBrd, canvas.width - xBrd);
      const centerY = getRandomDec(yBrd, canvas.height - yBrd);
      const gap = 0.0079;
      let theta = increment;
      const dSize = Math.min(canvas.width, canvas.height) * dRsize;
      const maxTheta = Math.floor(Math.random() * 50) + dSize;

      // Gradient for the background
      let grd = ctx.createLinearGradient(0, Math.random() * canvas.height, Math.random() * canvas.width, Math.random() * canvas.height);
      grd.addColorStop(Math.random(), htmlColors[0]);
      grd.addColorStop(Math.random(), htmlColors[1]);
      grd.addColorStop(Math.random(), htmlColors[2]);
      grd.addColorStop(Math.random(), htmlColors[3]);

      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.strokeStyle = "rgba(10,10,10,0.5)";
      ctx.lineWidth = 2;

      // Draw the spiral pattern
      function draw() {
        if (theta < maxTheta) {
          const newX = centerX + theta * Math.cos(theta) * gap;
          const newY = centerY + theta * Math.sin(theta) * gap;

          ctx.lineTo(newX, newY);
          theta += increment;
          ctx.stroke();
          requestAnimationFrame(draw);
        } else {
          requestAnimationFrame(addShadow);
        }
      }

      function addShadow() {
        if (ctx.shadowBlur < 0.0001) {
          ctx.shadowColor = "rgba(45,45,45,0.6)";
          ctx.shadowOffsetX = getRandomDec(-10, 10);
          ctx.shadowOffsetY = getRandomDec(-10, 10);
          ctx.shadowBlur += 15;
          ctx.stroke();
          requestAnimationFrame(addShadow);
        } else {
          ctx.stroke();
        }
      }

      requestAnimationFrame(draw);
    }

    // Initial setup for the canvas
    setCanvasSize();
    window.addEventListener('resize', setCanvasSize);

    let timer;
    canvas.addEventListener('click', e => e.detail === 1 && (timer = setTimeout(() => location.reload(), 275)));
    canvas.addEventListener('dblclick', () => {
      clearTimeout(timer);
      showModal();
    });

    // Modal and canvas scaling functionality
    function showModal() {
      const options = ['1k', '1kt', '2k', '2kt', '3k', '3kt', '4k', '4kt', '8k', '8kt', '16k', '16kt'];
      const modal = document.createElement('div');
      modal.className = 'modal';
      options.forEach(opt => {
        const btn = document.createElement('button');
        btn.textContent = opt;
        btn.onclick = () => {
          document.body.removeChild(modal);
          scaleCanvas(parseInt(opt), opt.includes('t'));
        };
        modal.appendChild(btn);
      });
      document.body.appendChild(modal);
    }

    function scaleCanvas(multiplier, transparent) {
      const originalAspectRatio = canvas.width / canvas.height;
      const upscaleHeight = 1024 * multiplier;
      const upscaleWidth = upscaleHeight * originalAspectRatio;

      const offscreenCanvas = document.createElement('canvas');
      const offscreenCtx = offscreenCanvas.getContext('2d');
      offscreenCanvas.width = upscaleWidth;
      offscreenCanvas.height = upscaleHeight;

      if (!transparent) {
        offscreenCtx.fillStyle = '#000000';
        offscreenCtx.fillRect(0, 0, upscaleWidth, upscaleHeight);
      }

      const scale = upscaleHeight / canvas.height;
      const scaledWidth = canvas.width * scale;
      const scaledHeight = canvas.height * scale;
      const offsetX = (upscaleWidth - scaledWidth) / 2;
      const offsetY = (upscaleHeight - scaledHeight) / 2;

      offscreenCtx.drawImage(canvas, offsetX, offsetY, scaledWidth, scaledHeight);

      const link = document.createElement('a');
      link.download = `F5_${multiplier}k_${transparent ? 'TP' : 'BLK'}.png`;
      link.href = offscreenCanvas.toDataURL('image/png');
      link.click();
    }

function releaseCanvas(canvas){canvas.width=1;canvas.style.width="1vw";canvas.height=1;canvas.style.height="1vh";const ctx=canvas.getContext("2d");ctx&&ctx.clearRect(0,0,1,1);canvas.remove()}window.addEventListener("pagehide",event=>{var canvases=document.getElementsByTagName("canvas");var canvasesList=Array.prototype.slice.call(canvases);canvasesList.forEach(releaseCanvas)});
  </script>
</body>
</html>
