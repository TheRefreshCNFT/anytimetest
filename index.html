<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { margin: 0; overflow: hidden; background-color: black; }
    canvas { display: block; touch-action: none; }
    .modal {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: #555; padding: 20px; border-radius: 10px;
    display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;
    box-shadow: 0 0 20px gold; z-index: 10;
}
.modal button {
    padding: 10px; background: #000; color: gold; border: none;
    font-weight: bold; cursor: pointer; box-shadow: 0 0 10px gold;
}
  </style>
</head>
<body>
<canvas id="patternCanvas"></canvas>
<script>
  const canvas = document.getElementById("patternCanvas");
  const ctx = canvas.getContext("2d");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  const shapes = [];
  const numShapes = 3;
  let time = 0;
  const maxOverlapRatio = 0.3;

  const colors = [
    'hsl('+ 360 * Math.random() +',100%,50%)', 'hsl('+ 360 * Math.random() +',100%,50%)', 'hsl('+ 360 * Math.random() +',100%,50%)',
    'hsl('+ 360 * Math.random() +',100%,50%)', 'hsl('+ 360 * Math.random() +',100%,50%)', 'hsl('+ 360 * Math.random() +',100%,50%)'
  ];

  function normalizeVector(vec) {
    const mag = Math.hypot(vec.x, vec.y);
    return { x: vec.x / mag, y: vec.y / mag };
  }

  function initializeShapes() {
    shapes.length = 0;
    const maxRadius = Math.min(canvas.width, canvas.height) / 2;

    let attempts = 0;
    while (shapes.length < numShapes && attempts < 2000) {
      const radius = Math.random() * (maxRadius / 2) + maxRadius / 2;

      const newShape = {
        x: Math.random() * (canvas.width - radius * 2) + radius,
        y: Math.random() * (canvas.height - radius * 2) + radius,
        radius,
        frequency: Math.random() * 21 + 1,
        phase: Math.random() * Math.PI * 2,
        lineDensity: Math.random() * 75 + 35,
        color: colors[Math.floor(Math.random() * colors.length)],
        flipPhase: 0,
        flipSpeed: Math.random() * 0.01 + 0.025,
        flipAxis: Math.random() < 0.5 ? 'x' : 'y',
        flipTarget: (Math.random() < 0.75 ? 1 : (Math.random() * 0.5 + 0.25)) * Math.PI * 2,
        rotationAxis: normalizeVector({ x: Math.random() - 0.5, y: Math.random() - 0.5 })
      };

      let valid = true;
      for (let shape of shapes) {
        const dx = shape.x - newShape.x;
        const dy = shape.y - newShape.y;
        const dist = Math.hypot(dx, dy);
        const minDist = shape.radius + newShape.radius;
        const maxOverlap = Math.min(shape.radius, newShape.radius) * maxOverlapRatio;
        if (dist < (minDist - maxOverlap)) {
          valid = false;
          break;
        }
      }

      if (valid) shapes.push(newShape);
      attempts++;
    }

    if (attempts >= 1000) {
      console.warn("Reached max attempts placing shapes without excessive overlap");
    }
  }


  function updateShapes() {
    for (let shape of shapes) {
      // Drastic wave frequency + phase jumps = wiggly chaos
      shape.frequency += (Math.random() - 0.5) * 0.25; // ⬆️ was 0.1
      shape.phase += (Math.random() - 0.5) * 0.5;     // ⬆️ was 0.25

      // Major positional jitter — this is the "teleportiness"
      const jitterX = (Math.random() - 0.5) * 64; // ⬆️ was 4
      const jitterY = (Math.random() - 0.5) * 64; // ⬆️ was 4
      shape.x = Math.max(shape.radius, Math.min(canvas.width - shape.radius, shape.x + jitterX));
      shape.y = Math.max(shape.radius, Math.min(canvas.height - shape.radius, shape.y + jitterY));

      // Faster flips
      shape.flipPhase += shape.flipSpeed * (Math.random() * 1.5 + 0.5); // randomizes rotation tick rate
      if (shape.flipPhase >= shape.flipTarget) {
        shape.flipPhase = 0;
        shape.flipAxis = Math.random() < 0.5 ? 'x' : 'y';
        shape.flipSpeed = Math.random() * 0.02 + 0.01; // ⬆️ faster flip speed
        shape.flipTarget = (Math.random() < 0.45 ? 1 : (Math.random() * 0.5 + 0.25)) * Math.PI * 2;
      }
    }
  }


  const noiseSeed = [];
  for (let i = 0; i < 256; i++) noiseSeed[i] = Math.random();

  function noise(x) {
    const i = Math.floor(x) % 256;
    const f = x - Math.floor(x);
    const u = f * f * (3 - 2 * f);
    return lerp(noiseSeed[i], noiseSeed[(i + 1) % 256], u);
  }

  function lerp(a, b, t) {
    return a + (b - a) * t;
  }


  function drawShape(shape) {
    const { x, y, radius, frequency, phase, lineDensity, color, flipPhase, rotationAxis } = shape;

    ctx.save(); // Save before transforming

    // Move origin to shape center
    ctx.translate(x, y);

    // Apply simulated 3D rotation around random axis
    const scale = Math.cos(flipPhase);      // Controls "thickness"
    const skew = Math.sin(flipPhase) * 2; // Adds perspective distortion
    const a = 1 + rotationAxis.x * skew;
    const b = rotationAxis.y * skew;
    const c = rotationAxis.x * skew;
    const d = 1 + rotationAxis.y * skew;
    ctx.transform(a * scale, b, c, d * scale, 0, 0); // Apply from centered origin

    // --- Draw filled wavy shape ---
    ctx.beginPath();
    for (let angle = 0; angle <= Math.PI * 2; angle += 0.00025) {
      const wave = Math.sin(angle * frequency + phase + Math.random() * 0.15) * (18 + Math.random() * 4);
      const r = radius + wave * 0.5 + Math.random() * 2;
      const posX = Math.cos(angle) * r;
      const posY = Math.sin(angle) * r;
      if (angle === 0) ctx.moveTo(posX, posY);
      else ctx.lineTo(posX, posY);
    }
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.globalAlpha = .75;
    ctx.fill();

    // --- Draw inner lines ---
    ctx.globalAlpha = 1.0;
    for (let i = 0; i < lineDensity; i++) {
      ctx.beginPath();
      const linePhase = (i / lineDensity) * Math.PI * 2;

      for (let angle = 0; angle <= Math.PI * 2; angle += 0.01) {
        const n = noise(angle * 0.5 + i * 0.1 + time * 0.2); // smooth organic wave
        const wave = Math.sin(angle * frequency + phase + linePhase) * 75 * n;
        const r = radius + wave * 0.9;

        const progress = i / lineDensity;
        // Puffiness factor based on flip thickness
        const puff = .5 - Math.abs(Math.cos(flipPhase)); // 0 at side view, 1 at flat view
        const puffCurve = Math.sin(progress * Math.PI); // 0 at edges, 1 in middle

        const puffedRadius = r * (progress + puff * 1 * puffCurve);

        const posX = Math.cos(angle) * puffedRadius;
        const posY = Math.sin(angle) * puffedRadius;


        if (angle === 0) ctx.moveTo(posX, posY);
        else ctx.lineTo(posX, posY);
      }

      // Simulated shading
      const shade = Math.floor(200 + noise(i * 0.5 + time * 0.1) * 55);
      ctx.strokeStyle = 'hsl('+ 360*Math.random() +',100%,50%)';
      ctx.stroke();
    }


    ctx.restore(); // Reset everything
  }


  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    updateShapes();
    for (let shape of shapes) {
      drawShape(shape);
    }
    time += 0.00000005;
    requestAnimationFrame(animate);
  }

  initializeShapes();
  animate();

  window.addEventListener("resize", () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    initializeShapes();
  });

  let timer;
  let lastTap = 0;
  const DOUBLE_TAP_DELAY = 300; // milliseconds

  // For mouse events on desktop, Android, etc.
  canvas.addEventListener("click", e => {
    if (e.detail === 1) {
      timer = setTimeout(() => location.reload(), DOUBLE_TAP_DELAY);
    }
  });

  canvas.addEventListener("dblclick", () => {
    clearTimeout(timer);
    showModal();
  });

  // For iOS (and other touch devices) double-tap detection
  canvas.addEventListener("touchend", function(e) {
    const currentTime = new Date().getTime();
    const tapInterval = currentTime - lastTap;
    if (tapInterval < DOUBLE_TAP_DELAY && tapInterval > 0) {
      // Double-tap detected; prevent the single-tap action
      e.preventDefault(); // prevents zooming and synthetic click events
      clearTimeout(timer);
      showModal();
    } else {
      // Single tap: schedule reload action if no double-tap follows
      timer = setTimeout(() => location.reload(), DOUBLE_TAP_DELAY);
    }
    lastTap = currentTime;
  });


 function showModal() {
             const options = ['1k', '1kt', '2k', '2kt', '3k', '3kt', '4k', '4kt', '8k', '8kt', '16k', '16kt'];
             const modal = document.createElement('div');
             modal.className = 'modal';
             if (modal) {
               modal.style.background = "#000";
               modal.style.boxShadow = `0 0 10px hsl(310, 100%, 50%)`;
             }
             options.forEach(opt => {
                 const btn = document.createElement('button');
                 btn.textContent = opt;
                 btn.onclick = () => {
                     document.body.removeChild(modal);
                     scaleCanvas(parseInt(opt), opt.includes('t'));
                 };
                 modal.appendChild(btn);
                 // Apply the styles dynamically
                 if (btn) {
                   btn.style.background = "#000";
                   btn.style.color = 'hsl(310, 100%, 50%)';
                   btn.style.boxShadow = `0 0 10px hsl(310, 100%, 50%)`;
                 }
               });
             document.body.appendChild(modal);
         }

         function scaleCanvas(multiplier, transparent) {
    // Calculate the target dimensions while preserving aspect ratio
    const originalAspectRatio = canvas.width / canvas.height;
    const upscaleHeight = 512 * multiplier;
    const upscaleWidth = upscaleHeight * originalAspectRatio;

    // Create the offscreen canvas
    const offscreenCanvas = document.createElement('canvas');
    const offscreenCtx = offscreenCanvas.getContext('2d');
    offscreenCanvas.width = upscaleWidth;
    offscreenCanvas.height = upscaleHeight;

    // Handle background
    if (!transparent) {
        offscreenCtx.fillStyle = '#000000'; // Black background
        offscreenCtx.fillRect(0, 0, upscaleWidth, upscaleHeight);
    }

    // Calculate scaling factors
    const scale = upscaleHeight / canvas.height;
    const scaledWidth = canvas.width * scale;
    const scaledHeight = canvas.height * scale;
    const offsetX = (upscaleWidth - scaledWidth) / 2;
    const offsetY = (upscaleHeight - scaledHeight) / 2;

    // Draw the original canvas onto the offscreen canvas
    offscreenCtx.drawImage(canvas, offsetX, offsetY, scaledWidth, scaledHeight);

    // Save the image
    const link = document.createElement('a');
    link.download = `glitchin_${multiplier}k_${transparent ? 'TP' : 'BLK'}.png`;
    link.href = offscreenCanvas.toDataURL('image/png');
    link.click();
}
</script>
</body>
</html>
