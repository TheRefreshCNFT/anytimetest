<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Contained Wavy Patterns</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: black; }
    canvas { display: block; touch-action: none; }
  </style>
</head>
<body>
<canvas id="patternCanvas"></canvas>
<script>
  const canvas = document.getElementById("patternCanvas");
  const ctx = canvas.getContext("2d");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // Global settings
  const shapes = [];
  const numShapes = 10; // Number of wavy shapes
  let time = 0;

  const colors = [
    "hsl(0, 100%, 50%)", "hsl(40, 100%, 50%)", "hsl(120, 100%, 50%)",
    "hsl(200, 100%, 50%)", "hsl(280, 100%, 50%)", "hsl(340, 100%, 50%)"
  ];

  // Initialize shapes with random parameters, constrained to canvas
  function initializeShapes() {
    shapes.length = 0; // Clear any existing shapes
    for (let i = 0; i < numShapes; i++) {
      const maxRadius = Math.min(canvas.width, canvas.height) / 4; // Max radius within bounds
      shapes.push({
        x: Math.random() * (canvas.width - maxRadius * 2) + maxRadius, // Constrained X
        y: Math.random() * (canvas.height - maxRadius * 2) + maxRadius, // Constrained Y
        radius: Math.random() * (maxRadius / 2) + maxRadius / 2, // Scaled radius
        frequency: Math.random() * 3 + 1, // Frequency of the waves
        phase: Math.random() * Math.PI * 2,
        lineDensity: Math.random() * 20 + 20, // Number of lines inside the shape
        color: colors[Math.floor(Math.random() * colors.length)],
      });
    }
  }

  // Update shape parameters smoothly for transitions
  function updateShapes() {
    for (let shape of shapes) {
      shape.frequency += (Math.random() - 0.5) * 0.02; // Random wave changes
      shape.phase += (Math.random() - 0.5) * 0.05;     // Slight phase shift

      // Contain positions within the canvas bounds
      shape.x = Math.max(shape.radius, Math.min(canvas.width - shape.radius, shape.x + (Math.random() - 0.5) * 2));
      shape.y = Math.max(shape.radius, Math.min(canvas.height - shape.radius, shape.y + (Math.random() - 0.5) * 2));
    }
  }

  // Draw a wavy shape with lines
  function drawShape(shape) {
    const { x, y, radius, frequency, phase, lineDensity, color } = shape;

    // Draw filled wavy shape
    ctx.beginPath();
    for (let angle = 0; angle <= Math.PI * 2; angle += 0.01) {
      const wave = Math.sin(angle * frequency + phase) * 20; // Wave distortion
      const r = radius + wave; // Distorted radius
      const posX = x + Math.cos(angle) * r;
      const posY = y + Math.sin(angle) * r;
      if (angle === 0) ctx.moveTo(posX, posY);
      else ctx.lineTo(posX, posY);
    }
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.3; // Semi-transparent fill
    ctx.fill();

    // Draw overlapping lines within the shape
    ctx.globalAlpha = 1.0;
    ctx.strokeStyle = "white";
    for (let i = 0; i < lineDensity; i++) {
      ctx.beginPath();
      const linePhase = (i / lineDensity) * Math.PI * 2; // Spread lines evenly
      for (let angle = 0; angle <= Math.PI * 2; angle += 0.01) {
        const wave = Math.sin(angle * frequency + phase + linePhase) * 20;
        const r = radius + wave * 0.5; // Slightly less wave distortion
        const posX = x + Math.cos(angle) * r * (i / lineDensity);
        const posY = y + Math.sin(angle) * r * (i / lineDensity);
        if (angle === 0) ctx.moveTo(posX, posY);
        else ctx.lineTo(posX, posY);
      }
      ctx.stroke();
    }
  }

  // Main animation loop
  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    updateShapes();
    for (let shape of shapes) {
      drawShape(shape);
    }
    time += 0.02;
    requestAnimationFrame(animate);
  }

  initializeShapes();
  animate();

  // Resize canvas dynamically
  window.addEventListener("resize", () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    initializeShapes(); // Reinitialize shapes on resize
  });
</script>
</body>
</html>
